# 🎴 Push_swap ソートアルゴリズム 初心者向けガイド

## 📚 目次
1. [基本的な仕組み](#基本的な仕組み)
2. [使える操作](#使える操作)
3. [サイズ別の戦略](#サイズ別の戦略)
4. [Turkアルゴリズムの詳細](#turkアルゴリズムの詳細)
5. [性能](#性能)

---

## 🎯 基本的な仕組み

### トランプの山札で例えると...

あなたの前に**2つの山札置き場（スタックAとB）**があります。

- **スタックA**: バラバラの数字のカードが積まれている
- **スタックB**: 最初は空っぽ
- **目標**: スタックAを小さい順に並べる（一番上が最小）

---

## 📜 使える操作

| 操作 | 説明 | 例 |
|------|------|-----|
| **sa** (swap a) | Aの上2枚を入れ替え | `[2,1,3]` → `[1,2,3]` |
| **ra** (rotate a) | Aの一番上を一番下に移動 | `[1,2,3]` → `[2,3,1]` |
| **rra** (reverse rotate a) | Aの一番下を一番上に移動 | `[1,2,3]` → `[3,1,2]` |
| **pb** (push b) | AからBへ1枚移動 | A:`[1,2]` B:`[]` → A:`[2]` B:`[1]` |
| **pa** (push a) | BからAへ1枚移動 | A:`[2]` B:`[1]` → A:`[1,2]` B:`[]` |

他にも `sb`, `rb`, `rrb`, `ss`, `rr`, `rrr` など、両方のスタックを同時に操作できるものもあります。

---

## 🎴 サイズ別の戦略

### 📦 2枚の時（超簡単）

```
入力: [2, 1]
操作: sa
結果: [1, 2]  完了！
```

**説明**: 上2枚を交換するだけ

---

### 🃏 3枚の時（パズル感覚）

**例: [3, 1, 2] を並べ替える**

```
ステップ1: 一番大きいカード(3)を探す
          → 先頭にある！

ステップ2: 3を下に送る
          [3, 1, 2]
            ↓ ra
          [1, 2, 3]

ステップ3: 上2枚を確認
          1 < 2 なので完了！
```

**考え方**:
- まず「一番大きいカードを下に追いやる」
- 残りの2枚は必要なら交換

**最大操作数**: 2回

---

### 🎴 5枚の時（賢い作戦）

**例: [5, 2, 4, 1, 3] を並べ替える**

**作戦**:
1. 小さいカードから順に「Bに避難」させる
2. 3枚だけ残したら、さっきの3枚ソートを使う
3. Bから戻す

**実行例**:

```
初期状態:
A: [5, 2, 4, 1, 3]
B: []

↓ 最小(1)を探して先頭に回転
A: [1, 3, 5, 2, 4]
B: []

↓ Bに避難 (pb)
A: [3, 5, 2, 4]
B: [1]

↓ 次の最小(2)を探して回転
A: [2, 4, 3, 5]
B: [1]

↓ Bに避難 (pb)
A: [4, 3, 5]
B: [2, 1]

↓ 3枚ソート
A: [3, 4, 5]
B: [2, 1]

↓ Bから戻す (pa × 2)
A: [1, 2, 3, 4, 5]
B: []

完了！
```

**平均操作数**: 6-12回

---

## 🏗️ Turkアルゴリズム（100枚以上）

### 🍽️ レストランの皿洗いの例え話

**状況**:
- **あなた (シンクA)**: 汚れた皿の山
- **友達 (シンクB)**: 助けてくれる人
- **目標**: シンクAの皿を綺麗に積み直す

---

### 📋 フェーズ1: 準備

```
まず2枚の皿を友達に渡す（スタックBへ）

「とりあえずこれ持っててー」
```

**コード**: `pb, pb`

---

### 🔄 フェーズ2: メインの作業（グリーディ戦略）

自分の山（A）から、**「今移動するのが一番楽な皿」**を毎回選ぶ

#### 楽さの計算方法

```
コスト = Aの回転数 + Bの回転数

例: Aの「30」をBに移したい
A: [10, 20, 30, 40, 50]
     ↑0  ↑1  ↑2  ↑3  ↑4

方法1: 前から回転 (ra)
    → 2回必要 (10, 20を下に送る)

方法2: 後ろから回転 (rra)
    → 3回必要 (50, 40を上に送る)

→ 方法1を選ぶ！ (2 < 3)
```

#### 最適化のポイント

**同じ方向なら同時回転可能**

```
Aを前に2回 + Bを前に3回
  ↓
rrを2回 + rbを1回
（同時実行で節約！）
```

**繰り返し**: 自分の山が3枚になるまで繰り返す

---

### 🎯 フェーズ3: 残り3枚

3枚ソートアルゴリズムで片付ける（最大2操作）

---

### ↩️ フェーズ4: 友達から返してもらう

友達の山から、常に**「一番大きい皿」**を取って、自分の山の**「正しい位置」**に挿入

```
例:
自分の山: [1, 3, 5, 7]
友達から: 6 を返してもらう

ステップ1: 正しい位置を見つける
          → 5と7の間

ステップ2: [1, 3, 5] まで回転

ステップ3: 6を受け取る (pa)

結果: [1, 3, 5, 6, 7]
```

---

### 🔧 フェーズ5: 最後の調整

一番小さい皿が上に来るように回転

```
[3, 4, 5, 1, 2]
  ↓ rra × 2
[1, 2, 3, 4, 5]
```

---

## 💡 なぜこの方法が賢いの？

### 🎯 グリーディ（欲張り）戦略とは

完璧な答えを探すのではなく、**「今この瞬間、一番良さそうな選択」**を繰り返す。

**日常の例**:
- 旅行で毎回「一番近い観光地」に行く
- 買い物で毎回「一番安いもの」を選ぶ
- ゲームで「一番近い敵から倒す」

完璧じゃないけど、**十分良い結果**になる！

---

## 📊 コスト計算の詳細

### 回転コストの計算

```python
def calc_rotation_cost(position, stack_size):
    forward_cost = position
    backward_cost = stack_size - position

    return min(forward_cost, backward_cost)

例:
position = 2, stack_size = 5
forward:  2回
backward: 3回
→ 2回を選択
```

### 同方向最適化

```
両方のスタックが同じ方向の場合:
  total_cost = max(cost_a, cost_b)
  （同時回転できるため）

異なる方向の場合:
  total_cost = cost_a + cost_b
  （順次実行が必要）
```

---

## 🏆 性能

### 操作数の比較

| 要素数 | 使用アルゴリズム | 平均操作数 | 42評価基準 | 結果 |
|--------|----------------|-----------|-----------|------|
| 2 | swap | 1 | - | ✓ |
| 3 | sort_three | 0-2 | ≤3 | ✓✓✓ |
| 5 | sort_small | 6-8 | ≤12 | ✓✓✓ |
| 100 | turk_sort | ~570 | <700 (5点) | ⭐⭐⭐⭐⭐ |
| 500 | turk_sort | ~5100 | <5500 (5点) | ⭐⭐⭐⭐⭐ |

### 日常の例えで説明

**100枚の場合**:
- 平均570回の操作
- これは「約5.7回の操作で1枚処理」
- 基準（700回）より**はるかに少ない！**

**500枚の場合**:
- 平均5100回の操作
- これは「約10回の操作で1枚処理」
- 基準（5500回）を**楽々クリア！**

---

## 🎓 まとめ

### 小さい数（2-5枚）
```
「目で見て、頭で考えて、最適な手を打つ」
→ パズルを解く感覚
```

### 大きい数（100枚以上）
```
「毎回『今一番楽な選択』をする」
→ ゲームで「一番近い敵から倒す」みたいな感じ
```

---

## 🎁 覚えておくポイント

1. ✅ **小さい時は賢く**: パズルみたいに最適解
2. ✅ **大きい時は欲張りに**: 毎回「今一番楽な手」
3. ✅ **助っ人を使う**: スタックBを作業台として活用
4. ✅ **完璧じゃなくても十分**: グリーディでも十分速い！

---

## 📚 アルゴリズムの時間計算量

| アルゴリズム | 時間計算量 | 空間計算量 |
|------------|-----------|-----------|
| sort_three | O(1) | O(1) |
| sort_small | O(n) | O(1) |
| turk_sort | O(n²) | O(1) |

**注**: push_swapの制約では、配列のソートのような O(n log n) は達成困難。
しかし、実用的には十分に高速！

---

## 🌟 Turkアルゴリズムの名前の由来

42コミュニティで**"Turkish Algorithm"**または**"Turk Sort"**と呼ばれている、
push_swap専用に最適化されたグリーディアルゴリズムです。

他の呼び方:
- **Cost-Based Greedy Sort** (コストベース貪欲法)
- **Two-Stack Greedy Algorithm** (2スタック貪欲法)

---

## 🔍 実装のポイント

### 1. インデックス化
```
元の値: [42, -17, 100, 3]
↓
インデックス: [2, 0, 3, 1]
```
どんな値でも0〜n-1の範囲で扱える！

### 2. ターゲット検索
```
スタックBで、index_a より小さい最大のインデックスを探す

例: index_a = 5
    stack_b = [2, 7, 4, 8]
    → target = 4 (5より小さい最大値)
```

### 3. 双方向最適化
```c
// 疑似コード
if (両方forward || 両方backward) {
    cost = max(cost_a, cost_b);  // 同時回転
} else {
    cost = cost_a + cost_b;      // 順次実行
}
```

---

**このガイドで、push_swapのソートアルゴリズムが理解できましたか？**

「レストランの皿洗い」をイメージすると、だいぶわかりやすくなると思います！🍽️✨

---

*作成日: 2025年*
*対象: 42 Tokyo push_swap プロジェクト*
