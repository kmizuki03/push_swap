%PDF-1.4
1 0 obj
<< /Type /Catalog /Pages 2 0 R >>
endobj
2 0 obj
<< /Type /Pages /Count 2 /Kids [ 3 0 R 4 0 R ] >>
endobj
3 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 5 0 R /Resources << /Font << /F1 7 0 R >> >> >>
endobj
4 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 6 0 R /Resources << /Font << /F1 7 0 R >> >> >>
endobj
5 0 obj
<< /Length 3672 >>
stream
BT
/F1 12 Tf
1 0 0 1 72 720 Tm
14 TL
(PUSH_SWAP メイン処理のやさしい解説) Tj
T*
() Tj
T*
(このドキュメントは、push_swap プログラムのエントリーポイント（main 関数まわり）を、プログラミング初心者でも読みやすいようにまとめたものです。) Tj
T*
() Tj
T*
(---) Tj
T*
() Tj
T*
(全体のながれ) Tj
T*
(・ 入力があるか確認 : コマンドライン引数の個数を見て、並べ替える数字が1つも渡されていないなら何もせず終了します。) Tj
T*
(・ スタック（リスト）の準備 : stack_a と stack_b という 2 本のリンクトリストを NULL（空の状態）で用意します。) Tj
T*
(・ 文字列を数値リストに変換 : parse_args で文字列の配列を読み取り、stack_a に数値ノードを順番に積み上げます。) Tj
T*
(・ すでに並んでいないかチェック : is_sorted で stack_a が最初から昇順なら、そのまま片付けて終了します。) Tj
T*
(・ リストの長さを数えて順位づけ : stack_size で要素数を数え、index_stack で小さい値から順番に番号（インデックス）を振ります。) Tj
T*
(・ 要素数に合わせてソート方法を選択 : choose_sort) Tj
T*
(  がリストの大きさに応じた関数（sa/sort_three/sort_small/turk_sort）を呼び出します。) Tj
T*
(・ 後始末 : 使ったメモリを free_stack で解放し、プログラムを終了します。) Tj
T*
() Tj
T*
(---) Tj
T*
() Tj
T*
(各処理の役わり) Tj
T*
() Tj
T*
(1. MAIN 関数 \(PUSH_SWAP.C\)) Tj
T*
(・ 目的 : プログラム全体の入り口で、処理の順番を管理します。) Tj
T*
(・ 初心者ポイント : まず argc（引数の数）を調べ、仕事がなければすぐ終わる、という「早期リターン」の書き方が使われています。) Tj
T*
() Tj
T*
(2. PARSE_ARGS \(PARSE.C\)) Tj
T*
(・ 目的 : 受け取った文字列を整数に変換し、stack_a というリンクトリストへ積み込みます。) Tj
T*
(・ 安全対策 :) Tj
T*
(・ is_number で数字かどうかをチェック。) Tj
T*
(・ check_overflow で int の範囲を越えていないか確認。) Tj
T*
(・ 重複チェック \(has_duplicates\) で同じ数字が複数ないか確認。) Tj
T*
(・ 初心者ポイント : 途中でエラーが見つかったら error_exit でメッセージを出し、確保したメモリを解放して終了します。) Tj
T*
() Tj
T*
(3. IS_SORTED \(UTILS.C\)) Tj
T*
(・ 目的 : stack_a の先頭から順番に値を見て、常に「次の値が現在の値以上」になっているかを確かめます。) Tj
T*
(・ 初心者ポイント : while ループでリストを1つずつ進めながら比較する典型的なパターンです。) Tj
T*
() Tj
T*
(4. STACK_SIZE と INDEX_STACK) Tj
T*
(・ stack_size \(stack.c\) : リストを最後までたどって要素数を数えるだけの関数です。) Tj
T*
(・ index_stack \(index_set.c\) : リスト全体を何度か走査しながら、「一番小さい値には0」「次に小さい値には1」…という具合に index) Tj
T*
(  を振り分けます。) Tj
T*
(・ 初心者ポイント : 値そのものではなく「順位」を付けておくと、後でソート手順を決めやすくなります。) Tj
T*
() Tj
T*
(5. CHOOSE_SORT（PUSH_SWAP.C 内の静的関数）) Tj
T*
(・ 目的 : 要素数に合わせて最適なソート戦略を選ぶ分岐です。) Tj
T*
(・ 2個だけなら sa（swap 操作）で済む。) Tj
T*
(・ 3個なら sort_three。) Tj
T*
(・ 5個以下なら sort_small。) Tj
ET
endstream
endobj
6 0 obj
<< /Length 1195 >>
stream
BT
/F1 12 Tf
1 0 0 1 72 720 Tm
14 TL
(・ それ以上は本格的な turk_sort に任せます。) Tj
T*
(・ 初心者ポイント : if / else if で条件を並べるときは、「小さいケースから順に」書いておくと読みやすくなります。) Tj
T*
() Tj
T*
(6. 後始末 \(FREE_STACK\)) Tj
T*
(・ 目的 : stack_a と stack_b に残っているノードを順に free してメモリを解放します。) Tj
T*
(・ 初心者ポイント : free_stack の中で NULL チェックをしているので、呼び出す側は安全に呼べます。) Tj
T*
() Tj
T*
(---) Tj
T*
() Tj
T*
(まとめ) Tj
T*
(・ main は「入力 → 変換 → チェック → ソート → 片付け」という一本道です。) Tj
T*
(・ 各補助関数は、1つの役割に集中して作られており、読み解きやすくなっています。) Tj
T*
(・ エラー処理やメモリ解放が関数にまとめられているので、安全な作りになっているのがポイントです。) Tj
T*
() Tj
T*
(初心者の方は、ここで紹介した関数を追いながら実際のコードを開き、処理の流れを追ってみると理解が深まります。) Tj
ET
endstream
endobj
7 0 obj
<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>
endobj
xref
0 8
0000000000 65535 f 
0000000009 00000 n 
0000000058 00000 n 
0000000123 00000 n 
0000000249 00000 n 
0000000375 00000 n 
0000004099 00000 n 
0000005346 00000 n 
trailer
<< /Size 8 /Root 1 0 R >>
startxref
5416
%%EOF
